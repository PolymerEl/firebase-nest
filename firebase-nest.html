<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../polymerfire/firebase-query.html">
<link rel="import" href="firebase-nest-behavior.html">
<!--
`firebase-nest` is a wrapper element around firebase-query and designed to work well with `firebase-value`.


@demo demo/index.html 
-->
<dom-module id="firebase-nest">
  <template>
    <firebase-query log="[[log]]" size="{{size}}" id="query" order-by-child="[[orderByChild]]" order-by-value="[[orderByValue]]" start-at="[[startAt]]" end-at="[[endAt]]" equal-to="[[equalTo]]" limit-to-first="[[limitToFirst]]" limit-to-last="[[limitToLast]]" data="{{data}}" disabled="[[disabled]]" path="[[path]]" log="[[log]]" app-name="[[appName]]"></firebase-query>
    <content></content>
  </template>
  <script>
  Polymer({

    is: 'firebase-nest',

    behaviors: [
      Polymer.firebaseNest.NestBehavior
    ],

    properties: {
      /**
       * Path to a Firebase root or endpoint. N.B. `path` is case sensitive.
       */
      path: {
        type: String
      },

      /**
       * The data to returned by firebase-query.
       */
      data: {
        type: Array,
        notify: true
      },

      // _data: {
      //   type: Array,
      // },

      dataSource: {
        notify: true,
        value: function() {
          return this._dataSource.bind(this);
        }
      },

      // dataSourceSize: {
      //   type: Number,
      //   notify: true,
      //   value: 50
      // },

      /**
       * `dataSourceDelay` the delay to wait before calling dataSource callback - it should give some time to fetch firebase data
       */
      dataSourceDelay: {
        type: Number,
        value: 200
      },

      /**
       * When true, Firebase listeners won't be activated. This can be useful
       * in situations where elements are loaded into the DOM before they're
       * ready to be activated (e.g. navigation, initialization scenarios).
       */
      disabled: {
        type: Boolean,
        value: false
      },

      /**
       * When true, will perform detailed logging.
       */
      log: {
        type: Boolean,
        value: false
      },

      /**
       * `size` reflect data.length. Size is debounced in firebase-query
       */
      size: {
        type: Number,
        notify: true
      },

      /* 
       * `allowSync`  set to true to make sure we sync with firebase. It HAS to be set to true if we are using two-way binding with dom-repeat ...
       */
      allowSync: {
        type: Boolean,
        // observer: '_observeAllowSync',
        value: false
      }
      /**
       * `_useDataSource`  a flag to know if we are usingData source - that helps dealing with reflecting data-source changes
       */
      // useDataSource: {
      //   type: Boolean,
      //   readOnly: true
      // }
    },

    observers: [
      // '_computeDataAsObject(data.splices)'
      // '_observeDataMutation(_data.*)'
      // '_observeData(data)'
    ],

    // _observeData: function(data) {
    //   this.set('data', data)
    // },

    // _observeDataMutation(changed) {
    //   this.set('data', data)
    // },

    // _observeData: function(changed) {
    //   console.info('DATACHANGED', changed);
    // },

    listeners: {
      'firebase-value': 'onFirebaseValue'
    },

    /* 
     * `_observePath` we need to reset the data if sync is not allowed 
     */
    // _observePath: function(path) {
    //   if(!this.allowSync) {
    //     this.$.query.data = this.$.query.zeroValue;  
    //   }
    // },

    // _observeAllowSync: function(allow) {
    //   this.$.query.__syncingToMemory = !allow;
    // },

    attached: function() {
      //we Highjack the behavior of firebase-query and prevent data to be written back to the db. If need be, we could go back to standard behavior depending on allowSync
      // console.info('CREATE NEST');
      this.$.query.__dataChanged = function() {
        // console.info('NEST CHANGE');
      };
    },

    onFirebaseValue: function(e, d) {
      e.stopPropagation();

      var firebaseKey = d.$key,
        index = this.data.findIndex(function(d) {
          return d.$key === firebaseKey;
        });

      //hack to prevent the change to be reflected to firebase !
      this.$.query.__syncingToMemory = true;
      this.set(['data', index].concat(d.key), d.value);
      // this.notifyPath(['data', index]);
      this.$.query.__syncingToMemory = false;

      // if(this._useDataSource) {
      //   this.fire('firebase-item-changed', {
      //     item: this.data[index],

      //   })
      // }
      // we might need to refresh some stuff based on this;
      // console.info('NEST', d);
      this.debounce('firebase-nest-refresh', function() {
        // console.info('FIRE NEST', d);
        // console.timeStamp('nest');
        this.fire('firebase-nest-refresh', this.data);
      }, 200);
    },

    _dataSource: function(opts, cb) {
      var items = this.data;
      if (opts.filters.length) {
        items = this._filter(items, opts.filters);
      }
      this.size = items.length;

      if (opts.sortOrder.length) {
        items = this._sort(items, opts.sortOrder);
      }

      var start = opts.page * opts.pageSize;
      var end = start + opts.pageSize;
      var slice = items.slice(start, end);
      cb(slice, items.length);
    },

    _sort: function(items, sorters) {
        this._sorters = sorters;
        return items.sort(this._multiSort.bind(this));

    },

    _multiSort: function(a, b) {
      return this._sorters.map(function(sort) {
        if (sort.direction === 'asc') {
          return this._compare(Polymer.Base.get(sort.path, a), Polymer.Base.get(sort.path, b));
        } else if (sort.direction === 'desc') {
          return this._compare(Polymer.Base.get(sort.path, b), Polymer.Base.get(sort.path, a));
        }
        return 0;
      }, this).reduce(function firstNonZeroValue(p, n) {
        return p ? p : n;
      }, 0);
    },

    _normalizeEmptyValue: function(value) {
      return [undefined, null].indexOf(value) >= 0 ? '' : value.toString();
    },

    _compare: function(a, b) {
      a = this._normalizeEmptyValue(a);
      b = this._normalizeEmptyValue(b);

      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    },

    _filter: function(items, filters) {
      return items.filter(function(item, index) {
        return filters.filter(function(filter) {
          var value = this._normalizeEmptyValue(Polymer.Base.get(filter.path, item));
          return value.toLowerCase().indexOf(filter.value.toString().toLowerCase()) === -1;
        }.bind(this)).length === 0;
      }, this);
    }

    // _computeDataAsObject: function(splices) {
    //   if (splices && splices.indexSplices) {
    //     splices.indexSplices.forEach(function(s) {
    //       s.removed.forEach(function(removed) {
    //         //work around this.delete not implemented https://github.com/Polymer/polymer/issues/2565
    //         delete(this.dataAsObject[removed.$key]);
    //         this.notifyPath('dataAsObject.' + removed.$key);
    //       });
    //       for (var i = 0; i < s.addedCount; i++) {
    //         var index = s.index + i;
    //         var obj = s.object[index];
    //         this.set('dataAsObject.' + obj.$key, obj);
    //       }
    //     }, this);
    // }
    // }
  });
  </script>
</dom-module>
